# У компании имеется следующий склад (см. рис), три ряда стеллажей, стоящие в ряд
#
# по 700 ед. Каждый стеллаж содержит 5 полок. Каждая полка содержит 6 ячеек. Между
# рядами стеллажей есть проходы. Между стеллажами в одном ряду проходов нет.
# Ширина полок одинакова и равна ширине прохода. Зеленым цветом обозначены
# проходы.
#
# Кладовщику выдается случайный перечень ячеек, из которых требуется взять товар.
# Помогите составить маршрут передвижения кладовщика по складу, начиная движение
# от стола, таким образом, чтобы он затратил минимально возможный путь.


# Данная задача кладовщика является по сути интерпретацией
# задачи о коммивояжере(Traveling Salesman Problem) которая является NP-полной,
# для которой время решения с увеличением размера склада будет расти экспоненциально.
# Можно использовать приближенный алгоритм, который пройдет за гораздо меньшее
# время и результат будет достаточно приближен к точному. Данную задачу можно разбить
# на задачу "о покрытии множества" для поиска минимального необходимого списка
# проходов между рядами для покрытия множества ячеек
#
require 'set'
# Примерный алгоритм для "покрытия множества"

# составить список необходимых ячеек
cell_needed = Set.new([1, 46, 234, 4357, 2121, 10000, 23, 4574, 22, 54, 800, 235, 1000])

# Список проходов между рядами, из которого будет выбираться покрытие
canals              = {}
canals['one']       = Set.new(Array.new(4200) { |i| i + 1 }) # проход слева от 1го ряда
canals['one-two']   = Set.new(Array.new(8400) { |i| i + 1 }) # проход между 1 и 2 рядами
canals['two-three'] = Set.new(Array.new(8400) { |i| i + 4200 }) # проход между 2 и 3 рядами
# проход справа от 3 ряда не имеет смысла учитывать, так как canals[3] в любом случае ближе к столу кладовщика

# переменная для хранения результата
final_canals = Set.new

# Далее будем выбирать проход с максимальным количеством ячеек, необходимых кладовщику
until cell_needed.empty?
  best_canal     = nil
  canals_covered = Set.new

  canals.each do |canal, cells|
    covered = cell_needed & cells
    if covered.length > canals_covered.length
      best_canal     = canal
      canals_covered = covered
    end
  end


  cell_needed -= canals_covered
  final_canals << best_canal
end

# таким образом найдем минимальное нужное количество проходов между рядами(более актуально для бОльших складов)
# далее пройдемся по всем проходам между рядами от ближайшего к столу к самому дальнем,
# в каждом проходе отсортируем ячейки по расстоянию до точки входа в проход
# точка входа в проход будет выбираться в зависимости от приближенности последней
# использованной ячейки в предыдущем проходе к своим точкам входа(движение "змейкой")
# в последнем проходе движемся в сторону стола(сверху вниз на рисунке) вне зависимости от последней использованной ячейки
